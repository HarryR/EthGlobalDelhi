// Generated by Claude AI

import { expect } from "chai";
import { ethers } from "hardhat";
import { TestIMTPoseidon } from "../src/contracts";

async function getTestIMTFactory() {
    const Poseidon2 = await ethers.getContractFactory('Poseidon2');
    const Poseidon2_lib = await Poseidon2.deploy();
    await Poseidon2_lib.waitForDeployment();
    const TestIMTFactory = await ethers.getContractFactory("TestIMTPoseidon",{
        libraries: {
            'Poseidon2': await Poseidon2_lib.getAddress()
        }
    });
    return TestIMTFactory
}

describe("IMTPoseidon", function () {
    let merkleTree: TestIMTPoseidon;
    const DEPTH = 10;
    const NAMESPACE = ethers.encodeBytes32String("TestTree");

    beforeEach(async function () {
        const TestIMTFactory = await getTestIMTFactory();
        merkleTree = await TestIMTFactory.deploy(NAMESPACE);
        await merkleTree.waitForDeployment();
    });

    describe("Basic functionality", function () {
        it("Should initialize with correct parameters", async function () {
            expect(await merkleTree.getDepth()).to.equal(DEPTH);
            expect(await merkleTree.getNamespace()).to.equal(NAMESPACE);
            expect(await merkleTree.getLeafCount()).to.equal(0);
        });

        it("Should append leaves and update leaf count", async function () {
            const leaf1 = ethers.keccak256(ethers.toUtf8Bytes("leaf1"));
            const leaf2 = ethers.keccak256(ethers.toUtf8Bytes("leaf2"));

            const index1 = await merkleTree.append.staticCall(leaf1);
            await merkleTree.append(leaf1);
            expect(index1).to.equal(0);
            expect(await merkleTree.getLeafCount()).to.equal(1);

            const index2 = await merkleTree.append.staticCall(leaf2);
            await merkleTree.append(leaf2);
            expect(index2).to.equal(1);
            expect(await merkleTree.getLeafCount()).to.equal(2);
        });

        it("Should update root when leaves are added", async function () {
            const initialRoot = await merkleTree.getRoot();
            
            const leaf1 = ethers.keccak256(ethers.toUtf8Bytes("leaf1"));
            await merkleTree.append(leaf1);
            
            const rootAfterFirst = await merkleTree.getRoot();
            expect(rootAfterFirst).to.not.equal(initialRoot);

            const leaf2 = ethers.keccak256(ethers.toUtf8Bytes("leaf2"));
            await merkleTree.append(leaf2);
            
            const rootAfterSecond = await merkleTree.getRoot();
            expect(rootAfterSecond).to.not.equal(rootAfterFirst);
        });
    });

    describe("Proof generation and verification", function () {
        let leaves: string[];

        beforeEach(async function () {
            leaves = [
                ethers.keccak256(ethers.toUtf8Bytes("leaf0")),
                ethers.keccak256(ethers.toUtf8Bytes("leaf1")),
                ethers.keccak256(ethers.toUtf8Bytes("leaf2")),
                ethers.keccak256(ethers.toUtf8Bytes("leaf3")),
            ];

            for (const leaf of leaves) {
                await merkleTree.append(leaf);
            }
        });

        it("Should generate proofs of correct length", async function () {
            for (let i = 0; i < leaves.length; i++) {
                const proof = await merkleTree.getProof(i);
                expect(proof.length).to.equal(DEPTH);
            }
        });

        it("Should generate valid proofs for all leaves", async function () {
            const root = await merkleTree.getRoot();

            for (let i = 0; i < leaves.length; i++) {
                const proof = Array.from(await merkleTree.getProof(i));
                const isValid = await merkleTree.verifyProof(proof, i, leaves[i], root);
                expect(isValid).to.be.true;
            }
        });

        it("Should reject invalid proofs", async function () {
            const root = await merkleTree.getRoot();
            const proof = Array.from(await merkleTree.getProof(0));
            
            // Wrong leaf
            const wrongLeaf = ethers.keccak256(ethers.toUtf8Bytes("wrong"));
            let isValid = await merkleTree.verifyProof(proof, 0, wrongLeaf, root);
            expect(isValid).to.be.false;

            // Wrong index
            isValid = await merkleTree.verifyProof(proof, 1, leaves[0], root);
            expect(isValid).to.be.false;

            // Wrong root
            const wrongRoot = ethers.keccak256(ethers.toUtf8Bytes("wrongroot"));
            isValid = await merkleTree.verifyProof(proof, 0, leaves[0], wrongRoot);
            expect(isValid).to.be.false;
        });

        it("Should handle edge cases", async function () {
            // Test with single leaf
            const TestIMTFactory = await getTestIMTFactory();
            const singleLeafTree = await TestIMTFactory.deploy(NAMESPACE);
            const singleLeaf = ethers.keccak256(ethers.toUtf8Bytes("single"));
            
            await singleLeafTree.append(singleLeaf);
            const singleRoot = await singleLeafTree.getRoot();
            const singleProof = Array.from(await singleLeafTree.getProof(0));
            
            const isValidSingle = await singleLeafTree.verifyProof(singleProof, 0, singleLeaf, singleRoot);
            expect(isValidSingle).to.be.true;
        });

        it("Should fail when accessing invalid leaf index", async function () {
            await expect(merkleTree.getProof(leaves.length)).to.be.revertedWith("Invalid index");
        });
    });

    describe("Consistency tests", function () {
        it("Should maintain consistency when adding leaves incrementally", async function () {
            const testLeaves = [];
            for (let i = 0; i < 3; i++) {
                testLeaves.push(ethers.keccak256(ethers.toUtf8Bytes(`test${i}`)));
            }

            // Add leaves one by one and verify all previous proofs still work
            for (let addCount = 1; addCount <= testLeaves.length; addCount++) {
                // Create fresh tree
                const TestIMTFactory = await getTestIMTFactory();
                const freshTree = await TestIMTFactory.deploy(NAMESPACE);
                
                // Add leaves up to addCount
                for (let i = 0; i < addCount; i++) {
                    await freshTree.append(testLeaves[i]);
                }

                const root = await freshTree.getRoot();

                // Verify all added leaves have valid proofs
                for (let i = 0; i < addCount; i++) {
                    const proof = Array.from(await freshTree.getProof(i));
                    const isValid = await freshTree.verifyProof(proof, i, testLeaves[i], root);
                    expect(isValid).to.be.true;
                }
            }
        });
    });
});